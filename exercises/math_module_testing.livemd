# Math Module Testing

```elixir
Mix.install([
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"},
  {:tested_cell, github: "brooklinjazz/tested_cell"},
  {:utils, path: "#{__DIR__}/../utils"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Setup

Ensure you type the `ea` keyboard shortcut to evaluate all Elixir cells before starting. Alternatively you can evaluate the Elixir cells as you read.

## Math Module Testing

Generally, we can split up our test suite into test cases. Each test case may require many assertions.

For this exercises, we're going to test a `Math` module that abstracts the operators for adding different data types together, like so.

<!-- livebook:{"force_markdown":true} -->

```elixir
Math.add(4, 4) # 
Math.add("a", "b") # "ab"
Math.add([1], [2]) # [1, 2]
```

Our **Happy-path** test cases (where our code is used as expected) could be the following.

`Math.add/2`

* add two integers
* add two strings
* add two lists

`Math.subtract/1`

* subtract two integers
* subtract two strings
* subtract two lists

We also want to consider **edge-case** test cases, also called **sad-path** or **unhappy path** when things go wrong, or the code is misused. For example, we might consider the following cases.

`Math.add/2`

* add a valid data type (integer, string, list) and an invalid data type.
* add two invalid data types.
* add two empty lists.
* add two empty strings.
* add a string by an empty string.
* add a list by an empty list.

`Math.subtract/2`

* subtract a valid data type (integer, string, list) and an invalid data type.
* subtract two invalid data types.
* subtract two empty lists.
* subtract two empty strings.
* subtract a string by an empty string.
* subtract a list by an empty list.

There can be a deceptive number of edge cases to consider. For example, we could build a growing list of edge-case permutations for each data type we want the `Math` module to handle.

Here, we've colored happy path tests green and edge-case tests yellow.

![](images/test%20cases.png)

By planning test cases, we can anticipate possible edge cases and ensure we understand the desired behavior of the feature.

Test and implement a `Math` module. Include at least two assertions for the happy path cases (**strings**, **lists**, and **integers**.)

```elixir
defprotocol Math do
  @doc "Provides Add and Subtract functionality"
  @fallback_to_any true
  # @fallback_to_any allows the below for: Any implementation
  def add(a, b)
  def subtract(a, b)
end

defimpl Math, for: Integer do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defimpl Math, for: BitString do
  def add(a, b), do: a <> b
  def subtract(a, b), do: Regex.compile!(b) |> Regex.replace(a, "") |> String.trim()
end

defimpl Math, for: List do
  def add(a, b), do: a ++ b
  def subtract(a, b), do: a -- b
end

defimpl Math, for: Any do
  # This is here to throw a tuple rater than an error. Bonus!
  def add(_a, _b), do: {:error, :bad_type}
  def subtract(_a, _b), do: {:error, :bad_type}
end
```

```elixir
ExUnit.start(auto_run: false)

defmodule MathTest do
  use ExUnit.Case

  describe "add/2" do
    test "add/2 with integers happy path" do
      assert Math.add(1, 1) == 2
      assert Math.add(-1, -5) == -6
    end

    test "add/2 with strings happy path" do
      assert Math.add("a", "b") == "ab"
      assert Math.add("ab", "BA") == "abBA"
    end

    test "add/2 with lists happy path" do
      assert Math.add([1], [2]) == [1, 2]
      assert Math.add([:ok], [:error]) == [:ok, :error]
    end

    # Edge cases

    test "add/2 with mixed types, int first" do
      assert_raise ArithmeticError, fn -> Math.add(10, "-2") end
    end

    test "add/2 with mixed types, string first" do
      assert_raise ArgumentError, fn -> Math.add("10", 3) end
    end

    test "add/2 with mixed types, list first" do
      assert Math.add([:test], "a") == [:test | "a"]
    end

    test "add/2 Int to invalid data type" do
      assert_raise ArithmeticError, fn -> Math.add(1, %{}) end
    end

    test "add/2 String to invalid data type" do
      assert_raise ArgumentError, fn -> Math.add("Modern", %{}) end
    end

    test "add/2 List to invalid data type" do
      assert Math.add(["Item"], %{}) == ["Item" | %{}]
    end

    test "add/2 Invaid data types" do
      # assert_raise Protocol.UndefinedError, fn -> Math.add(%{}, %{}) end
      assert Math.add(true, false) == {:error, :bad_type}
    end

    test "add/2 two empty lists" do
      assert Math.add([], []) == []
    end

    test "add/2 two empty strings" do
      assert Math.add("", "") == ""
    end

    test "add/2 a non-empty string to an empty string" do
      assert Math.add("foo", "") == "foo"
      assert Math.add("", "bar") == "bar"
    end

    test "add/2 a non-empty list to an empty list" do
      assert Math.add(["words"], []) == ["words"]
      assert Math.add([], ["wallaby"]) == ["wallaby"]
    end
  end

  describe "subtract/2" do
    test "subtract/2 Integers, happy path" do
      assert Math.subtract(2, 2) == 0
      assert Math.subtract(5, 0) == 5
      assert Math.subtract(0, -10) == 10
    end

    test "subtract/2 Strings, happy path" do
      assert Math.subtract("moonknight", "knight") == "moon"
      assert Math.subtract("hexagon", "pie") == "hexagon"
      assert Math.subtract("mirror", "") == "mirror"
    end

    test "subtract/2 Lists, happy path" do
      assert Math.subtract([1, 2, 3, 4, 5], [1, 2, 3]) == [4, 5]
    end

    test "subtract/2 a valid data type and an invalid data type." do
      assert_raise ArithmeticError, fn -> Math.subtract(1, %{}) end
      assert_raise FunctionClauseError, fn -> Math.subtract("Word", %{}) end
      assert_raise ArgumentError, fn -> Math.subtract(["rocko"], %{}) == ["rocko"] end
    end

    test "subtract two invalid data types." do
      # assert_raise Protocol.UndefinedError, fn -> Math.subtract(%{}, %{}) end
      assert Math.subtract(%{}, %{}) == {:error, :bad_type}
    end

    test "subtract two empty lists." do
      assert Math.subtract([], []) == []
    end

    test "subtract two empty strings." do
      assert Math.subtract("", "") == ""
    end

    test "subtract a string by an empty string." do
      assert Math.subtract("fizz", "") == "fizz"
    end

    test "subtract a list by an empty list." do
      assert Math.subtract(["this", :is, 'a', "list"], []) == ["this", :is, 'a', "list"]
    end
  end
end

ExUnit.run()
```

### Bonus: Edge Cases

Decide how to handle calling the `Math.add/2` and `Math.subtract/2` functions with invalid data.
For example, you might raise a [FunctionClauseError](https://hexdocs.pm/elixir/FunctionClauseError.html) using guards.

Note that if you expect to raise an error, it's usually idiomatic to name our functions using a bang `!` symbol, so `Math.add/2` and `Math.subtract/2` should be renamed to `Math.add!/2` and `Math.subtract!/2`.

<!-- livebook:{"force_markdown":true} -->

```elixir
Math.add!(1, 1)
2

Math.add!(%{}, %{})
** (FunctionClauseError) no function clause matching in Math.add/2  
```

Alternatively or in addition, you might choose to change the return value to an `{:ok, value}` tuple or `{:error, error}` tuple.

<!-- livebook:{"force_markdown":true} -->

```elixir
Math.add(%{}, %{})
{:error, :invalid_data}
```

Test and implement these edge cases on your `Math` module above.

## Commit Your Progress

Run the following in your command line from the beta_curriculum folder to track and save your progress in a Git commit.

```
$ git add .
$ git commit -m "finish math module testing exercise"
```

## Up Next

| Previous                           | Next                                                   |
| ---------------------------------- | -----------------------------------------------------: |
| [ExUnit](../reading/exunit.livemd) | [Product Filters](../exercises/product_filters.livemd) |

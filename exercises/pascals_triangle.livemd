# Pascal's Triangle

```elixir
Mix.install([
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"},
  {:tested_cell, github: "brooklinjazz/tested_cell"},
  {:utils, path: "#{__DIR__}/../utils"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Setup

Ensure you type the `ea` keyboard shortcut to evaluate all Elixir cells before starting. Alternatively you can evaluate the Elixir cells as you read.

## Pascal's Triangle

In this exercise, you're going to generate Pascal's Triangle for a certain number of rows.

In Pascal's Triangle, each number is the sum of the two integers above it.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
a[1]
b1[1]
b2[1]
c1[1]
c2[2]
c3[1]
d1[1]
d2[3]
d3[3]
d4[1]
e1[1]
e2[4]
e3[6]
e4[4]
e5[1]

a --> b1
a --> b2

b1 --> c1
b1 --> c2

b2 --> c2
b2 --> c3

c1 --> d1
c1 --> d2

c2 --> d2
c2 --> d3

c3 --> d3
c3 --> d4

d1 --> e1
d1 --> e2

d2 --> e2
d2 --> e3

d3 --> e3
d3 --> e4

d4 --> e4
d4 --> e5
```

<!-- livebook:{"break_markdown":true} -->

We can also represent Pascal's triangle as a list of lists.

<!-- livebook:{"force_markdown":true} -->

```elixir
[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 3, 6, 3, 1]]
```

In the Elixir cell below, finish the `of/1` function in the `Pascal` module which will
return Pascal's triangle in a list for `n` number of rows.

<!-- livebook:{"force_markdown":true} -->

```elixir
Pascal.of(1)
[
  [1]
]

Pascal.of(2)
[
  [1],
  [1, 1],
]

Pascal.of(5)
[
  [1],
  [1, 1],
  [1, 2, 1],
  [1, 3, 3, 1],
  [1, 4, 6, 4, 1]
]
```

```elixir
defmodule Pascal do
  @doc """
  Calculates and returns Pascal's triangle to a height of N
  """

  @spec of(integer()) :: [integer()]
  def of(rows), do: get_rows([[1]], rows - 1)

  @spec get_rows([integer()], integer()) :: [integer()]
  defp get_rows(triangle, row_number)

  # Base case. Reverse the list of lists as we've been PREPENDING to this point
  defp get_rows(triangle, 0), do: triangle |> Enum.reverse()

  defp get_rows(triangle, row_number) do
    # We only want to operate on the last calcutated row, at the head of our
    # list of lists
    last_row = triangle |> hd

    # The values in our new row are the sum of the values in the last_row, chuncked
    # every 2 numbers with a step of one. 
    values =
      last_row
      |> Enum.chunk_every(2, 1)
      # Using the capture operator here until it stops looking weird.
      |> Enum.map(&Enum.sum/1)

    # This is cheaper, I think, than doing [[1] ++ values | triange] below
    new_row = [1 | values]
    get_rows([new_row | triangle], row_number - 1)
  end
end
```

```elixir
## Core logic

last_row = [1]

after_first =
  Enum.chunk_every(last_row, 2, 1)
  |> Enum.map(&Enum.sum/1)

# Recurse this, [new_row | triangle], into the function.
new_row = [1 | after_first]
```

```elixir
Pascal.of(6)
```

## Commit Your Progress

Run the following in your command line from the beta_curriculum folder to track and save your progress in a Git commit.

```
$ git add .
$ git commit -m "finish pascals triangle exercise"
```

## Up Next

| Previous                                   | Next                                                     |
| ------------------------------------------ | -------------------------------------------------------: |
| [Factorial](../exercises/factorial.livemd) | [Computer Hardware](../reading/computer_hardware.livemd) |

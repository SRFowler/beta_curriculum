# Product Filters

```elixir
Mix.install([
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"},
  {:tested_cell, github: "brooklinjazz/tested_cell"},
  {:utils, path: "#{__DIR__}/../utils"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Product Filters

You're going to build an application where users search for products based on certain filters.

We have an application where users search for products based on certain filters.
Each product is a map with a `:name`, `:category`, and `:price` (in cents).

<!-- livebook:{"force_markdown":true} -->

```elixir
products = [
  %{name: "Laptop", category: :tech, price: 100000},
  %{name: "Phone", category: :tech, price: 50000},
  %{name: "Chocolate", category: :snacks, price: 200},
  %{name: "Shampoo", category: :health, price: 1000}
]
```

Test and implement a `Products.filter/2` function which accepts a list of items
and a keyword list of filters.

You should be able to filter be:

1. a partial case-insensitive `:name` field.
2. a `:min` and `:max` price.
3. an exact `:category` field as an atom.

For example:

<!-- livebook:{"force_markdown":true} -->

```elixir
Products.filter(products, name: "l")
[
  %{name: "Chocolate", category: :snacks, price: 200},
  %{name: "Laptop", category: :tech, price: 100000}
]

Products.filter(products, category: :tech)
[
  %{name: "Laptop", category: :tech, price: 100000}
  %{name: "Phone", category: :tech, price: 50000}
]

Products.filter(products, min: 1000)
[
  %{name: "Laptop", category: :tech, price: 100000},
  %{name: "Phone", category: :tech, price: 50000},
  %{name: "Shampoo", category: :health, price: 1000},
]

Products.filter(products, max: 1000)
[
  %{name: "Chocolate", category: :snacks, price: 200},
  %{name: "Shampoo", category: :health, price: 1000},
]

Products.filter(products, min: 300, max: 1200)
[
  %{name: "Shampoo", category: :health, price: 1000},
]

Products.filter(products, name: "P", max: 100000, min: 50000, category: :tech)
[
  %{name: "Laptop", category: :tech, price: 100000},
  %{name: "Phone", category: :tech, price: 50000},
]
```

Ensure you include at least one test for each filter, and one test which combines all filters.

```elixir
defmodule Products do
  def filter(products, filters \\ []) do
    products
    |> Enum.filter(fn item ->
      String.contains?(
        item[:name] |> String.downcase(),
        (filters[:name] || "") |> String.downcase()
      )
    end)
    |> Enum.filter(fn item ->
      filters[:category] == nil || filters[:category] == item[:category]
    end)
    |> Enum.filter(fn item -> filters[:min] == nil || filters[:min] <= item[:price] end)
    |> Enum.filter(fn item -> filters[:max] == nil || filters[:max] >= item[:price] end)
  end
end

ExUnit.start(auto_run: false)

defmodule ProductsTest do
  use ExUnit.Case

  @products [
    %{name: "Laptop", category: :tech, price: 100_000},
    %{name: "Phone", category: :tech, price: 50000},
    %{name: "Chocolate", category: :snacks, price: 200},
    %{name: "Shampoo", category: :health, price: 1000}
  ]

  test "filter/2 with empty filters should return all products" do
    assert Products.filter(@products) == [
             %{name: "Laptop", category: :tech, price: 100_000},
             %{name: "Phone", category: :tech, price: 50000},
             %{name: "Chocolate", category: :snacks, price: 200},
             %{name: "Shampoo", category: :health, price: 1000}
           ]
  end

  test "filter/2 with full name should return only exact match" do
    assert Products.filter(@products, name: "Phone") == [
             %{name: "Phone", category: :tech, price: 50000}
           ]
  end

  test "filter/2 full name with mixed case should return only exact match" do
    assert Products.filter(@products, name: "PhONe") == [
             %{name: "Phone", category: :tech, price: 50000}
           ]
  end

  test "filter/2 with partial name should return only matching items" do
    assert Products.filter(@products, name: "A") == [
             %{name: "Laptop", category: :tech, price: 100_000},
             %{name: "Chocolate", category: :snacks, price: 200},
             %{name: "Shampoo", category: :health, price: 1000}
           ]
  end

  test "filter/2 category shound return only matching items" do
    assert Products.filter(@products, category: :tech) == [
             %{name: "Laptop", category: :tech, price: 100_000},
             %{name: "Phone", category: :tech, price: 50000}
           ]
  end

  test "filter/2 with Min should return only items with price above the passed value" do
    assert Products.filter(@products, min: 1000) == [
             %{name: "Laptop", category: :tech, price: 100_000},
             %{name: "Phone", category: :tech, price: 50000},
             %{name: "Shampoo", category: :health, price: 1000}
           ]
  end

  test "filter/2 with Max should return only items with price below the passed value" do
    assert Products.filter(@products, min: 2000) == [
             %{name: "Laptop", category: :tech, price: 100_000},
             %{name: "Phone", category: :tech, price: 50000}
           ]
  end

  test "filter/2 with Min and Max should return only items with price in range" do
    assert Products.filter(@products, min: 1000, max: 60_000) == [
             %{category: :tech, name: "Phone", price: 50000},
             %{category: :health, name: "Shampoo", price: 1000}
           ]
  end

  test "filter/2 with Max below all items should return no items" do
    assert Products.filter(@products, max: 0) == []
  end

  test "filter/2 with name, category, min and max should return only items in range" do
    assert Products.filter(@products, min: 0, max: 60_000, name: "o", category: :tech) == [
             %{name: "Phone", category: :tech, price: 50000}
           ]
  end

  test "filter/2 on category with no members should return nothing" do
    assert Products.filter(@products, category: :movies) == []
  end
end

ExUnit.run()
```

```elixir
filter = [name: "Chocolate"]

items =
  [
    %{name: "Chocolate", category: :snacks, price: 200},
    %{name: "Laptop", category: :tech, price: 100_000}
  ]
  |> Enum.filter(fn item ->
    String.contains?(item[:name] |> String.downcase(), (filter[:name] || "") |> String.downcase())
  end)

# |> Enum.filter(fn item -> filter[:category] == :nil || filter[:category] ==  item[:category] end)
# |> Enum.filter(fn item -> filter[:min] == :nil || filter[:min] <= item[:price] end)
# |> Enum.filter(fn item -> filter[:max] == :nil || filter[:max] >= item[:price] end)

# filter[:category] || "True"
```

## Commit Your Progress

Run the following in your command line from the beta_curriculum folder to track and save your progress in a Git commit.

```
$ git add .
$ git commit -m "finish product filters exercise"
```

## Up Next

| Previous                                                       | Next                                                 |
| -------------------------------------------------------------- | ---------------------------------------------------: |
| [Math Module Testing](../exercises/math_module_testing.livemd) | [ExUnit With Mix](../reading/exunit_with_mix.livemd) |

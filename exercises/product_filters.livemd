# Product Filters

```elixir
Mix.install([
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"},
  {:tested_cell, github: "brooklinjazz/tested_cell"},
  {:utils, path: "#{__DIR__}/../utils"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Product Filters

You're going to build an application where users search for products based on certain filters.

We have an application where users search for products based on certain filters.
Each product is a map with a `:name`, `:category`, and `:price` (in cents).

<!-- livebook:{"force_markdown":true} -->

```elixir
products = [
  %{name: "Laptop", category: :tech, price: 100000},
  %{name: "Phone", category: :tech, price: 50000},
  %{name: "Chocolate", category: :snacks, price: 200},
  %{name: "Shampoo", category: :health, price: 1000}
]
```

Test and implement a `Products.filter/2` function which accepts a list of items
and a keyword list of filters.

You should be able to filter be:

1. a partial case-insensitive `:name` field.
2. a `:min` and `:max` price.
3. an exact `:category` field as an atom.

For example:

<!-- livebook:{"force_markdown":true} -->

```elixir
Products.filter(products, name: "l")
[
  %{name: "Chocolate", category: :snacks, price: 200},
  %{name: "Laptop", category: :tech, price: 100000}
]

Products.filter(products, category: :tech)
[
  %{name: "Laptop", category: :tech, price: 100000}
  %{name: "Phone", category: :tech, price: 50000}
]

Products.filter(products, min: 1000)
[
  %{name: "Laptop", category: :tech, price: 100000},
  %{name: "Phone", category: :tech, price: 50000},
  %{name: "Shampoo", category: :health, price: 1000},
]

Products.filter(products, max: 1000)
[
  %{name: "Chocolate", category: :snacks, price: 200},
  %{name: "Shampoo", category: :health, price: 1000},
]

Products.filter(products, min: 300, max: 1200)
[
  %{name: "Shampoo", category: :health, price: 1000},
]

Products.filter(products, name: "P", max: 100000, min: 50000, category: :tech)
[
  %{name: "Laptop", category: :tech, price: 100000},
  %{name: "Phone", category: :tech, price: 50000},
]
```

Ensure you include at least one test for each filter, and one test which combines all filters.

```elixir
defmodule Products do
  def filter(products, filters \\ []) do
    products
    |> Enum.filter(fn item ->
      String.contains?(
        item[:name] |> String.downcase(),
        (filters[:name] || "") |> String.downcase()
      )
    end)
    |> Enum.filter(fn item ->
      filters[:category] == nil || filters[:category] == item[:category]
    end)
    |> Enum.filter(fn item -> filters[:min] == nil || filters[:min] <= item[:price] end)
    |> Enum.filter(fn item -> filters[:max] == nil || filters[:max] >= item[:price] end)
  end
end

ExUnit.start(auto_run: false)

defmodule ProductsTest do
  use ExUnit.Case

  products = [
    %{name: "Laptop", category: :tech, price: 100_000},
    %{name: "Phone", category: :tech, price: 50000},
    %{name: "Chocolate", category: :snacks, price: 200},
    %{name: "Shampoo", category: :health, price: 1000}
  ]

  describe "Empty filters should return all products" do
    assert length(Products.filter(products)) == 4
  end

  describe "Filter with full name should return only exact match" do
    assert length(Products.filter(products, name: "Phone")) == 1
  end

  describe "Filter full name with mixed case should return only exact match" do
    assert length(Products.filter(products, name: "PhONe")) == 1
  end

  describe "Filter with partial name should return only matching items" do
    assert length(Products.filter(products, name: "A")) == 3
  end

  describe "Filter category shound return only matching items" do
    assert length(Products.filter(products, category: :tech)) == 2
  end

  describe "Filter with Min should return only items with price above the passed value" do
    assert length(Products.filter(products, min: 1000)) == 3
  end

  describe "Filter with Max should return only items with price below the passed value" do
    assert length(Products.filter(products, min: 2000)) == 2
  end

  describe "Filter with Min and Max should return only items with price in range" do
    assert length(Products.filter(products, min: 1000, max: 60_000)) == 2
  end

  describe "Filter with Max below all items should return no items" do
    assert length(Products.filter(products, max: 0)) == 0
  end

  describe "Filter with name, category, min and max should return only items in range" do
    assert length(Products.filter(products, min: 0, max: 60_000, name: "o", category: :tech)) == 1
  end

  describe "Filter on category with no members should return nothing" do
    assert length(Products.filter(products, category: :movies)) == 0
  end
end

ExUnit.run()
```

```elixir
filter = [name: "Chocolate"]

items =
  [
    %{name: "Chocolate", category: :snacks, price: 200},
    %{name: "Laptop", category: :tech, price: 100_000}
  ]
  |> Enum.filter(fn item ->
    String.contains?(item[:name] |> String.downcase(), (filter[:name] || "") |> String.downcase())
  end)

# |> Enum.filter(fn item -> filter[:category] == :nil || filter[:category] ==  item[:category] end)
# |> Enum.filter(fn item -> filter[:min] == :nil || filter[:min] <= item[:price] end)
# |> Enum.filter(fn item -> filter[:max] == :nil || filter[:max] >= item[:price] end)

# filter[:category] || "True"
```

## Commit Your Progress

Run the following in your command line from the beta_curriculum folder to track and save your progress in a Git commit.

```
$ git add .
$ git commit -m "finish product filters exercise"
```

## Up Next

| Previous                                                       | Next                                                 |
| -------------------------------------------------------------- | ---------------------------------------------------: |
| [Math Module Testing](../exercises/math_module_testing.livemd) | [ExUnit With Mix](../reading/exunit_with_mix.livemd) |
